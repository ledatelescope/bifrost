
CXX            ?= @CXX@
NVCC           ?= @NVCC@
LINKER         ?= @CXX@
CPPFLAGS       ?= @CPPFLAGS@
CXXFLAGS       ?= @CXXFLAGS@
NVCCFLAGS      ?= @NVCCFLAGS@
LDFLAGS        ?= @LDFLAGS@ @LIBS@
DOXYGEN        ?= @DX_DOXYGEN@
PYBUILDFLAGS   ?= @PYBUILDFLAGS@
PYINSTALLFLAGS ?= @PYINSTALLFLAGS@

HAVE_CXX14    ?= @HAVE_CXX14@

HAVE_RECVMSG  ?= @HAVE_RECVMSG@

HAVE_CUDA     ?= @HAVE_CUDA@

GPU_ARCHS     ?= @GPU_ARCHS@

CUDA_HOME     ?= @CUDA_HOME@
CUDA_LIBDIR   ?= $(CUDA_HOME)/lib
CUDA_LIBDIR64 ?= $(CUDA_HOME)/lib64
CUDA_INCDIR   ?= $(CUDA_HOME)/include

CPPFLAGS += -I{bifrost_include} -I. -I$(CUDA_INCDIR)
LDFLAGS += -L{bifrost_library} -lbifrost

PYTHON_BINDINGS_FILE={libname}_generated.py
PYTHON_WRAPPER_FILE={libname}.py

.PHONY: all
all: lib{libname}.so $(PYTHON_BINDINGS_FILE) $(PYTHON_WRAPPER_FILE)

define run_ctypesgen
	@PYTHON@ -c 'from ctypesgen import main as ctypeswrap; ctypeswrap.main()' -l$1 -I. -I{bifrost_include} $^ -o $@
	# WAR for 'const char**' being generated as POINTER(POINTER(c_char)) instead of POINTER(c_char_p)
	sed -i 's/POINTER(c_char)/c_char_p/g' $@
	# WAR for a buggy WAR in ctypesgen that breaks type checking and auto-byref functionality
	sed -i 's/def POINTER/def POINTER_not_used/' $@
	# WAR for a buggy WAR in ctypesgen that breaks string buffer arguments (e.g., as in address.py)
	sed -i 's/class String/String = c_char_p\nclass String_not_used/' $@
	sed -i 's/String.from_param/String_not_used.from_param/g' $@
	sed -i 's/def ReturnString/ReturnString = c_char_p\ndef ReturnString_not_used/' $@
	sed -i '/errcheck = ReturnString/s/^/#/' $@
endef

define run_wrapper
	@PYTHON@ {bifrost_script}/wrap_bifrost_plugin.py $1
endef

lib{libname}.so: {libname}.o
	$(CXX) -o lib{libname}.so {libname}.o -lm -shared -fopenmp $(LDFLAGS)

%.o: %.cpp {includes}
	$(CXX) $(CXXFLAGS) $(CPPFLAGS) $(GCCFLAGS) $(TARGET_ARCH) -c $(OUTPUT_OPTION) $<

%.o: %.cu {includes}
	$(NVCC) $(NVCCFLAGS) $(CPPFLAGS) -Xcompiler "$(GCCFLAGS)" $(TARGET_ARCH) -c $(OUTPUT_OPTION) $<

$(PYTHON_BINDINGS_FILE): {includes}
	$(call run_ctypesgen,{libname},{includes})

$(PYTHON_WRAPPER_FILE): $(PYTHON_BINDINGS_FILE)
	$(call run_wrapper,$(PYTHON_BINDINGS_FILE))

clean:
	rm -f lib{libname}.so {libname}.o $(PYTHON_BINDINGS_FILE) $(PYTHON_WRAPPER_FILE)
